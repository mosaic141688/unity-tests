"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const immutable_1 = require("immutable");
const eventemitter3_1 = require("eventemitter3");
const dependency_graph_1 = require("dependency-graph");
const unit_1 = require("./unit");
const type_1 = require("./type");
function valueTag(name) {
    if (name.startsWith('@')) {
        return name;
    }
    else {
        return `@${name}`;
    }
}
exports.valueTag = valueTag;
function valueName(name) {
    if (name.startsWith('@')) {
        return name.slice(1, name.length);
    }
    else {
        return name;
    }
}
exports.valueName = valueName;
function unitTag(name) {
    if (name.startsWith('#')) {
        return name;
    }
    else {
        return `#${name}`;
    }
}
exports.unitTag = unitTag;
function unitName(name) {
    if (name.startsWith('#')) {
        return name.slice(1, name.length);
    }
    else {
        return name;
    }
}
exports.unitName = unitName;
class Store extends eventemitter3_1.EventEmitter {
    constructor() {
        super();
        this.data = immutable_1.Map();
        this.units = {};
        this.deps = new dependency_graph_1.DepGraph();
        this.configs = immutable_1.Map();
    }
    // Tagged
    lookup(name) {
        if (name.startsWith('@')) {
            return this.lookupValue(valueName(name));
        }
        if (name.startsWith('#')) {
            const unit = this.lookupUnit(unitName(name));
            return unit.run();
        }
        throw Error(`Can not find ${name} in store.`);
    }
    /*
     * Registering value in the store by name
     *
     * To overwrite the value in the store one can register a new value by the
     * same name. This can be done only if new value has the same type.
     *
     * When value is registered we go through its dependant units and mark
     * them as dirty.
     *
     * We also emit change:value event
     *
     */
    registerValue(name, value) {
        const current_value = this.data.get(name);
        if (current_value) {
            if (type_1.resolveTypes(current_value.type, value.type)) {
                this.data = this.data.set(name, value);
            }
            else {
                throw Error(`New value (${value.type}) does not match the type of current value (${current_value.type})`);
            }
        }
        else {
            this.data = this.data.set(name, value);
            this.deps.addNode(valueTag(name));
        }
        this.markDependantUnitsAsDirty(name);
        this.emit('change:value', name);
    }
    /*
     * When value in the store changes we need to mark all units that depend
     * on it as dirty.
     *
     * For that we figure out the order of updates from dependency graph and
     * mark all units in that order.
     *
     * We also emit change:unit events for each dirty unit
     */
    markDependantUnitsAsDirty(name) {
        ramda_1.forEach(dep => {
            this.lookupUnit(unitName(dep)).dirty = true;
            this.emit('change:unit', unitName(dep));
        }, ramda_1.filter(dep => {
            return this.deps.dependantsOf(valueTag(name)).includes(dep);
        }, this.deps.overallOrder()));
    }
    lookupValue(name) {
        const value = this.data.get(name);
        if (value) {
            return value;
        }
        else {
            throw Error(`Value with name ${name} is not registered in the store.`);
        }
    }
    // Unit configs
    registerConfig(name, config) {
        this.configs = this.configs.set(name, config);
        const deps = unit_1.extractUnitConfigDeps(config);
        this.checkConfigDependencies(name, deps);
        this.emit('change:config', name);
    }
    lookupConfig(name) {
        const config = this.configs.get(name);
        if (config) {
            return config;
        }
        else {
            throw Error(`Config with name ${name} is not registered in the store.`);
        }
    }
    // Unit management
    startUnit(name) {
        const config = this.lookupConfig(name);
        this.units[name] = new unit_1.default(this, name, config, this.deps.dependenciesOf(unitTag(name)));
    }
    lookupUnit(name) {
        const unit = this.units[name];
        if (unit) {
            return unit;
        }
        else {
            throw Error(`Unit with name ${name} is not running`);
        }
    }
    checkConfigDependencies(name, deps) {
        if (deps.includes(unitTag(name))) {
            throw Error(`Unit config ${name} refers itself in its dependencies`);
        }
        this.deps.addNode(unitTag(name));
        deps.forEach(dep => this.deps.addDependency(unitTag(name), dep));
    }
    run() {
        this.deps.overallOrder().forEach(dep => {
            if (dep.startsWith('#')) {
                this.startUnit(unitName(dep));
            }
        });
    }
}
exports.default = Store;
//# sourceMappingURL=store.js.map
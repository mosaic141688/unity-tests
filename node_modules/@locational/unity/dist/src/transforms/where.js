"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const any_1 = require("./any");
const any_2 = require("../values/any");
const parser_1 = require("../expression/parser");
const list_1 = require("../values/list");
function whereTransform(value_type, options) {
    const expression = any_1.expectExpression(options);
    const { input_type, output_type } = any_1.matchTypes(value_type, '[{a}]', '[{a}]');
    const section_deps = any_1.extractDeps(options);
    const falseValue = any_2.toValue(false);
    /*
     * All transforms are unsafe because we rely on typechecking that happened
     * before to assume type of input that we get.
     *
     * And we must ensure that the type of output we produce conforms to
     * the output type signature of the transform.
     *
     * Because of that transform code can seem weird.
     *
     * In theory we could use type checking inside of transforms, but that
     * is very expensive.
     */
    function transform(input, deps) {
        const new_content = input.content.filter(element => {
            const local_deps = Object.assign({ '$element': element }, deps);
            const local_expression = parser_1.resolve_local(local_deps, expression);
            const result = parser_1.evaluate(local_expression);
            return (!result.equals(falseValue));
        });
        return new list_1.default({ type: output_type, content: new_content });
    }
    return {
        input_type,
        output_type,
        deps: section_deps,
        transform
    };
}
exports.default = whereTransform;
//# sourceMappingURL=where.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const expectations_1 = require("./expectations");
const ramda_1 = require("ramda");
const commands_1 = require("./commands");
/*
 * Gather all dependencies occuring in expression
 *
 * We do not return local dependencies (name starting with $)
 * Local dependencies are injected by transform builders
 */
function deps(expression) {
    const [command, args] = expectations_1.expectExpression(expression);
    if (command === 'identity') {
        return [];
    }
    if (command === 'value') {
        return [];
    }
    if (command === 'dep') {
        if (typeof args === 'string') {
            if (args.startsWith('@') || args.startsWith('#') || args.startsWith('$')) {
                return args.startsWith('$') ? [] : [args];
            }
            else {
                throw Error(`Dependency name must start with @, #, or $`);
            }
        }
        else {
            throw Error(`Expected dependency ${args} to be a string`);
        }
    }
    if (Array.isArray(args)) {
        return ramda_1.reduce((acc, a) => acc.concat(deps(a)), [], args);
    }
    return deps(args);
}
exports.deps = deps;
/*
 * Recursively resolve all dependencies in expression
 * replacing them with values from store
 *
 * Ignores local dependencies (name starting with $)
 * Local dependencies should be injected by transform
 * builders with resolve_local
 */
function resolve_global(store, expression) {
    const [command, args] = expectations_1.expectExpression(expression);
    if (command === 'identity') {
        return expression;
    }
    if (command === 'value') {
        return expression;
    }
    if (command === 'dep') {
        if (typeof args === 'string') {
            if (args.startsWith('$')) {
                return { [command]: args };
            }
            else {
                return { identity: store.lookup(args) };
            }
        }
        else {
            throw Error(`Expected dependency ${args} to be a string`);
        }
    }
    if (Array.isArray(args)) {
        return {
            [command]: ramda_1.map(a => resolve_global(store, a), args)
        };
    }
    return {
        [command]: resolve_global(store, args)
    };
}
exports.resolve_global = resolve_global;
/*
 * Recursively resolve all dependencies in expression
 * replacing them with values from local depmap
 */
function resolve_local(depmap, expression) {
    const [command, args] = expectations_1.expectExpression(expression);
    if (command === 'identity') {
        return expression;
    }
    if (command === 'value') {
        return expression;
    }
    if (command === 'dep') {
        if (typeof args === 'string') {
            const resolved_value = depmap[args];
            if (resolved_value) {
                return { identity: resolved_value };
            }
            else {
                throw Error(`Could not find dependency ${args} in depmap ${depmap}`);
            }
        }
        else {
            throw Error(`Expected dependency ${args} to be a string`);
        }
    }
    if (Array.isArray(args)) {
        return {
            [command]: ramda_1.map(a => resolve_local(depmap, a), args)
        };
    }
    return {
        [command]: resolve_local(depmap, args)
    };
}
exports.resolve_local = resolve_local;
/*
 * Evaluate expression to single value
 */
function evaluate(expression) {
    const [command, args] = expectations_1.expectExpression(expression);
    switch (command) {
        case 'value':
            return commands_1.value(args);
        case 'identity':
            return args;
        case 'gt':
            return commands_1.gt(args);
        case 'lt':
            return commands_1.lt(args);
        case 'eq':
            return commands_1.eq(args);
        case 'neq':
            return commands_1.neq(args);
        case 'plus':
            return commands_1.plus(args);
        case 'path':
            return commands_1.path(args);
        default:
            throw Error(`Unknown command ${command}`);
    }
}
exports.evaluate = evaluate;
//# sourceMappingURL=parser.js.map
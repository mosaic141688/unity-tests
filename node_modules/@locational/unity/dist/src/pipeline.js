"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const any_1 = require("./transforms/any");
const where_1 = require("./transforms/where");
const ramda_1 = require("ramda");
const sort_1 = require("./transforms/sort");
const map_1 = require("./transforms/map");
const reduce_1 = require("./transforms/reduce");
const group_1 = require("./transforms/group");
const group_list_1 = require("./transforms/group_list");
/*
 * Create new pipeline section from config object
 * Passes input_type to transform builder for typechecking
 *
 * {
 *     type: 'where',
 *     options: {
 *         expression: {gt: [{dep: '$element'}, {value: 18}]}
 *     }
 * }
 */
function section(input_type, config) {
    switch (config.type) {
        case 'where':
            return where_1.default(input_type, config.options);
        case 'sort':
            return sort_1.default(input_type, config.options);
        case 'map':
            return map_1.default(input_type, config.options);
        case 'reduce':
            return reduce_1.default(input_type, config.options);
        case 'group':
            return group_1.default(input_type, config.options);
        case 'group_list':
            return group_list_1.default(input_type, config.options);
        default:
            throw Error(`No transform with type ${config.type}`);
    }
}
exports.section = section;
/*
 * Create a pipeline of transfroms from config
 */
function pipeline(input_type, config) {
    return ramda_1.map(c => section(input_type, c), config);
}
exports.pipeline = pipeline;
/*
 * Extract all deps from pipeline config
 */
function extractPipelineConfigDeps(config) {
    return ramda_1.uniq(ramda_1.reduce((acc, transform_config) => {
        return acc.concat(any_1.extractDeps(transform_config.options));
    }, [], config));
}
exports.extractPipelineConfigDeps = extractPipelineConfigDeps;
//# sourceMappingURL=pipeline.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const immutable_1 = require("immutable");
const type_1 = require("../../src/type");
ava_1.test('resolveTypes() returns result of trying to match two type strings', t => {
    const expected = {
        match: true,
        generics: {
            a: 'number'
        }
    };
    // Simple matches
    t.is(type_1.resolveTypes('number', 'number'), 'number');
    t.is(type_1.resolveTypes('[number]', '[number]'), '[number]');
    t.is(type_1.resolveTypes('{name: string, age: number}', '{name: string, age: number}'), '{name: string, age: number}');
    t.is(type_1.resolveTypes('[{name: string, age: number}]', '[{name: string, age: number}]'), '[{name: string, age: number}]');
    t.is(type_1.resolveTypes('number', 'string'), null);
    t.is(type_1.resolveTypes('[number]', '[string]'), null);
    t.is(type_1.resolveTypes('{name: string, age: number}', '{name: number, age: number}'), null);
    t.is(type_1.resolveTypes('{name: string, age: number}', '{nick: string, age: number}'), null);
    t.is(type_1.resolveTypes('{name: string, age: number}', '{score: number, age: number}'), null);
    // Same fields, but different order
    t.is(type_1.resolveTypes('[{name: string, age: number}]', '[{age: number, name: string}]'), '[{name: string, age: number}]');
    // Simple generics
    t.is(type_1.resolveTypes('a', 'a'), 'a');
    t.is(type_1.resolveTypes('[a]', '[a]'), '[a]');
    t.is(type_1.resolveTypes('number', 'a'), 'number');
    t.is(type_1.resolveTypes('[number]', '[a]'), '[number]');
    t.is(type_1.resolveTypes('[number]', 'a'), null);
    t.is(type_1.resolveTypes('[number]', '[string]'), null);
    // Generics in records
    t.is(type_1.resolveTypes('{a}', '{a}'), '{a}');
    t.is(type_1.resolveTypes('{name: string, age: number}', '{name: a, age: number}'), '{age: number, name: string}');
    t.is(type_1.resolveTypes('{name: string, age: number, b}', '{name: string, a}'), '{name: string, age: number}');
    t.is(type_1.resolveTypes('{name: string, age: number, score: number}', '{name: string, score: a, b}'), '{name: string, score: number, age: number}');
    // Nested generics
    t.is(type_1.resolveTypes('[{a}]', '[{a}]'), '[{a}]');
    t.is(type_1.resolveTypes('[{name: string, age: a}]', '[{name: string, age: number}]'), '[{name: string, age: number}]');
    // Same generic value a can't resolve to two types
    t.is(type_1.resolveTypes('{name: string, age: a, score: a}', '{name: string, age: string, score: number'), null);
});
ava_1.test('toTypeString() returns string representation of type', t => {
    const typestrings = [
        'number',
        '[number]',
        '{name: string}',
        '{name: string, age: number}',
        '{name: a}',
        '{a}',
    ];
    for (const typestring of typestrings) {
        t.is(type_1.toTypeString(type_1.fromTypeString(typestring)), typestring);
    }
});
ava_1.test('applyGenerics() applies generics found when matching two types onto third type', t => {
    t.throws(() => { type_1.applyGenerics('number', '[a]', 'string'); });
    t.deepEqual(type_1.applyGenerics('number', 'a', 'string'), { input_type: 'number', output_type: 'string' });
    t.deepEqual(type_1.applyGenerics('number', 'a', 'a'), { input_type: 'number', output_type: 'number' });
    t.deepEqual(type_1.applyGenerics('[number]', '[a]', '[a]'), { input_type: '[number]', output_type: '[number]' });
    t.deepEqual(type_1.applyGenerics('[number]', '[a]', 'a'), { input_type: '[number]', output_type: 'number' });
    t.deepEqual(type_1.applyGenerics('{name: string, age: number}', '{a}', '{name: string, age: number}'), { input_type: '{name: string, age: number}', output_type: '{name: string, age: number}' });
    t.deepEqual(type_1.applyGenerics('{name: string, age: number}', '{name: a, b}', '{name: a}'), { input_type: '{name: string, age: number}', output_type: '{name: string}' });
    t.deepEqual(type_1.applyGenerics('{name: string, age: number}', '{name: a, b}', '{b}'), { input_type: '{name: string, age: number}', output_type: '{age: number}' });
    t.deepEqual(type_1.applyGenerics('{name: string, age: number}', '{a}', '{a, score: number}'), { input_type: '{name: string, age: number}', output_type: '{score: number, name: string, age: number}' });
    // TODO
    // t.deepEqual(
    //     applyGenerics('{name: string, age: number}', '{a, age: b}', '{a, score: b}'),
    //     { input_type: '{age: number, name: string}', output_type: '{score: number, name: string, age: number}' }
    // )
});
ava_1.test('fromTypeString() returns map representation of type', t => {
    t.truthy(type_1.fromTypeString('number')
        .equals(immutable_1.fromJS({
        number: true
    })));
    t.truthy(type_1.fromTypeString('[number]')
        .equals(immutable_1.fromJS({
        list: { number: true }
    })));
    // Generic types
    t.truthy(type_1.fromTypeString('[a]')
        .equals(immutable_1.fromJS({
        list: { a: true }
    })));
    t.truthy(type_1.fromTypeString('*number')
        .equals(immutable_1.fromJS({
        computed: { number: true }
    })));
    t.truthy(type_1.fromTypeString('[*number]')
        .equals(immutable_1.fromJS({
        list: { computed: { number: true } }
    })));
    t.truthy(type_1.fromTypeString('{}')
        .equals(immutable_1.fromJS({
        record: {}
    })));
    t.truthy(type_1.fromTypeString('{a}')
        .equals(immutable_1.fromJS({
        record: { a: immutable_1.Map() }
    })));
    t.truthy(type_1.fromTypeString('{name: a, age: number}')
        .equals(immutable_1.fromJS({
        record: { name: { a: true }, age: { number: true } }
    })));
    t.truthy(type_1.fromTypeString('{name: string, a}')
        .equals(immutable_1.fromJS({
        record: { name: { string: true }, a: immutable_1.Map() }
    })));
    t.truthy(type_1.fromTypeString('{name: string, age: number}')
        .equals(immutable_1.fromJS({
        record: {
            name: { string: true },
            age: { number: true },
        }
    })));
    t.truthy(type_1.fromTypeString('{name: *string, age: number}')
        .equals(immutable_1.fromJS({
        record: {
            name: { computed: { string: true } },
            age: { number: true },
        }
    })));
    t.truthy(type_1.fromTypeString('{name: string, groups: [string], count: *number}')
        .equals(immutable_1.fromJS({
        record: {
            name: { string: true },
            groups: { list: { string: true } },
            count: { computed: { number: true } },
        }
    })));
    t.truthy(type_1.fromTypeString('{group: string, users: {name: string, full_name: *string, years: [number]}}').equals(immutable_1.fromJS({
        record: {
            group: { string: true },
            users: {
                record: {
                    name: { string: true },
                    full_name: { computed: { string: true } },
                    years: { list: { number: true } },
                }
            }
        }
    })));
});
//# sourceMappingURL=type_test.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const store_1 = require("../../src/store");
const any_1 = require("../../src/values/any");
ava_1.test('Tags and names helpers', t => {
    t.is(store_1.valueTag('name'), '@name');
    t.is(store_1.valueTag('@name'), '@name');
    t.is(store_1.valueName('name'), 'name');
    t.is(store_1.valueName('@name'), 'name');
    t.is(store_1.unitTag('name'), '#name');
    t.is(store_1.unitTag('#name'), '#name');
    t.is(store_1.unitName('name'), 'name');
    t.is(store_1.unitName('#name'), 'name');
});
// TODO: Test store.lookup()
ava_1.test('registerValue() registers new value in the store', t => {
    const store = new store_1.default();
    t.throws(() => store.lookupValue('n'));
    store.registerValue('n', any_1.toValue(1));
    t.truthy(store.lookupValue('n').equals(any_1.toValue(1)));
});
ava_1.test('registerValue() throws if we register value of different type by the same name', t => {
    const store = new store_1.default();
    store.registerValue('list', any_1.toValue([1, 2, 3]));
    store.registerValue('list', any_1.toValue([5, 6]));
    t.throws(() => store.registerValue('list', any_1.toValue(['a', 'b', 'c'])));
});
ava_1.test.cb('registerValue() emits event', t => {
    t.plan(2);
    const store = new store_1.default();
    store.on('change:value', name => {
        t.is(name, 'list');
        if (store.lookupValue('list').equals(any_1.toValue([5, 6])))
            t.end();
    });
    store.registerValue('list', any_1.toValue([1, 2, 3]));
    store.registerValue('list', any_1.toValue([5, 6]));
});
ava_1.test('lookupValue() returns value from store by name', t => {
    const store = new store_1.default();
    store.registerValue('n', any_1.toValue(1));
    t.truthy(store.lookupValue('n').equals(any_1.toValue(1)));
});
ava_1.test('lookupValue() throws if value is not found by name', t => {
    const store = new store_1.default();
    t.throws(() => store.lookupValue('no_such_value'));
});
ava_1.test('registerConfig() throws if Unit config references itself in input', t => {
    const store = new store_1.default();
    const config = {
        input: { dep: '#u1' },
        pipeline: []
    };
    t.throws(() => { store.registerConfig('u1', config); });
});
ava_1.test('registerConfig() throws if config referesces itself', t => {
    const store = new store_1.default();
    const config = {
        input: { dep: '#u1' },
        pipeline: []
    };
    t.throws(() => { store.registerConfig('u1', config); });
});
ava_1.test('registerConfig() throws if dependency does not exist', t => {
    const store = new store_1.default();
    store.registerValue('min_num', any_1.toValue(1));
    const config_a = {
        input: { value: [1, 2, 3] },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { dep: '#u2' }
                        ]
                    }
                }
            }
        ]
    };
    t.throws(() => { store.registerConfig('u1', config_a); });
});
ava_1.test('lookupConfig() returns the config by name', t => {
    const store = new store_1.default();
    const config = {
        input: { value: 1 },
        pipeline: []
    };
    store.registerConfig('u1', config);
    t.deepEqual(store.lookupConfig('u1'), config);
});
ava_1.test('lookupConfig() throws if config is not found by name', t => {
    const store = new store_1.default();
    t.throws(() => store.lookupConfig('u1'));
});
ava_1.test('startUnit() starts a valid Unit from config', t => {
    const store = new store_1.default();
    const config = {
        input: { value: 1 },
        pipeline: []
    };
    store.registerConfig('u1', config);
    t.notThrows(() => { store.startUnit('u1'); });
});
ava_1.test('startUnit() resolves dependencies', t => {
    const store = new store_1.default();
    store.registerValue('min_num', any_1.toValue(1));
    const config = {
        input: { value: [1, 2, 3] },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { dep: '@min_num' }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u1', config);
    store.startUnit('u1');
    t.truthy(store.lookupUnit('u1').run().equals(any_1.toValue([2, 3])));
});
ava_1.test('lookupUnit() return unit by name if it is running', t => {
    const store = new store_1.default();
    const config = {
        input: { value: 1 },
        pipeline: []
    };
    store.registerConfig('u1', config);
    store.startUnit('u1');
    t.truthy(store.lookupUnit('u1').run().equals(any_1.toValue(1)));
});
ava_1.test('lookupUnit() throws if unit is not running', t => {
    const store = new store_1.default();
    const config = {
        input: { value: 1 },
        pipeline: []
    };
    store.registerConfig('u1', config);
    t.throws(() => store.lookupUnit('u1'));
});
ava_1.test.cb('Store emits change:unit when value dependency of some unit has changed', t => {
    const store = new store_1.default();
    store.registerValue('min_num', any_1.toValue(1));
    const config = {
        input: { value: [1, 2, 3] },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { dep: '@min_num' }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u1', config);
    store.run();
    t.is(store.lookupUnit('u1').dirty, true);
    t.truthy(store.lookupUnit('u1').run().equals(any_1.toValue([2, 3])));
    t.is(store.lookupUnit('u1').dirty, false);
    store.on('change:unit', name => {
        t.is(name, 'u1');
        t.is(store.lookupUnit('u1').dirty, true);
        t.truthy(store.lookupUnit('u1').run().equals(any_1.toValue([3])));
        t.end();
    });
    store.registerValue('min_num', any_1.toValue(2));
});
ava_1.test.cb('Store emits change:unit when unit dependency of some unit has changed', t => {
    const store = new store_1.default();
    store.registerValue('min_num', any_1.toValue(1));
    const config_a = {
        input: { value: [1, 2, 3, 4, 5] },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { dep: '@min_num' }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u1', config_a);
    const config_b = {
        input: { dep: '#u1' },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { value: 1 }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u2', config_b);
    store.run();
    t.is(store.lookupUnit('u2').dirty, true);
    t.truthy(store.lookupUnit('u2').run().equals(any_1.toValue([2, 3, 4, 5])));
    t.is(store.lookupUnit('u2').dirty, false);
    store.on('change:unit', name => {
        if (name == 'u1') {
            t.is(store.lookupUnit('u1').dirty, true);
            t.is(store.lookupUnit('u2').dirty, false);
        }
        if (name == 'u2') {
            t.is(store.lookupUnit('u1').dirty, true);
            t.is(store.lookupUnit('u2').dirty, true);
            t.truthy(store.lookupUnit('u2').run().equals(any_1.toValue([3, 4, 5])));
            t.end();
        }
    });
    store.registerValue('min_num', any_1.toValue(2));
});
ava_1.test('run() starts all registered units in correct order', t => {
    const store = new store_1.default();
    store.registerValue('min_num', any_1.toValue(1));
    const config_a = {
        input: { value: [1, 2, 3] },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { dep: '@min_num' }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u1', config_a);
    const config_b = {
        input: { dep: '#u1' },
        pipeline: [
            {
                type: 'where',
                options: {
                    expression: {
                        gt: [
                            { dep: '$element' },
                            { value: 2 }
                        ]
                    }
                }
            }
        ]
    };
    store.registerConfig('u2', config_b);
    store.run();
    t.truthy(store.lookupUnit('u2').run().equals(any_1.toValue([3])));
});
//# sourceMappingURL=store_test.js.map
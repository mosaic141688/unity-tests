# Things we need to be able to do:
## MUST
### configuration of application
    - [ ] convert JSON configuration of an application into a running application
    
    Possible: Yes
    Implemented: No

    - [ ] validate the configuration against a schema

    Possible: Yes
    Implemented: No

    - [ ] track/persist any changes made to configuration (e.g. edits to a filter)

    Possible: Yes
    Implemented: Not completely

    Runnables are simple Immutable.js records. You save them into the Store into separate namespace,
    so they can be modified later.
    Pipelines then can lookup runnables by name from the store.

    - [ ] handle user permissions down to level of any cell in a table

    Possible: Hardly
    That's a very tough thing to implement in any framework.
    We can do access guards on store (conditional lookup/register based on some other value in the store)

### link to application components
    - [ ] we are building with Vue, but important (for clarity and separation of responsibilities at least) that we could potentially use another approach

    Possible: Yes
    Implemented: Yes

    - [ ] store and pipeline accessible where they are needed in Vue

    Possible: Yes
    Implemented: No (need to convent Fruitplate into a library)

    - [ ] no data observed in Vue

    Possible: Yes
    Implemented: Yes
    Components and Store emit events on change

    - [ ] Vue components as dumb as possible

    Possible: Yes

### store and retrieve data on device
    - [ ] store/retrieve single value (e.g. output of reduce fn on table)
    
    Possible: Yes
    Implemented: No

    Components for now only emit changes.
    Need to add possibility to write output of component pipeline into the Store.

    - [ ] store/retrieve table of data (array of rows)

    Possible: Yes
    Implemented: Yes

    - [ ] CRUD data in store

    Possible: Yes
    Implemented: Yes

    - [ ] access the store from Vue-land

    Possible: Yes
    Implemented: Yes

    - [ ] transparent local persistence of store (e.g. IndexedDB)

    Possible: Yes
    Implemented: No

    Can implement Store adapters that persist data into different kinds of storage.

    - [ ] ability to interface with a syncing component

    Possible: Yes
    Implemented: No

    Store.lookup and Store.register should be enough for that?
    Maybe add another method to list all stored names.

### pipelines to transform data
    - [ ] create an arbitrary pipeline from configuration, combining
        - [ ] filter
        - [ ] sort
        - [ ] map
        - [ ] reduce
        - [ ] group_by (with ability to run a given pipeline on each group and recombine)
        - [ ] complex (reduce-then-map) i.e. requiring some state to calc 'proportion_per_region = count / sum(count for table)'

    Possible: Yes
    Implemented: Partially
    
    'where' filter and 'max' transform are implemented as examples
    Any other kind of filter or transform is possible.
    Currently runnables don't have access to Store though.
    Could add a local Pipeline/Component store?

    - [ ] run a pipeline on a given set of data

    Possible: Yes
    Implemented: Yes

    - [ ] cache pipeline outputs to avoid unnecessary calculations (incl. the common elements of a set of pipelines)

    Possible: Yes
    Implemented: No

    Can add Components optimization where we go through all components and extract common pipelines.

    - [ ] able to pass data to renderers (same point as below)

    Possible: Yes
    Implemented: Yes
    Components emit on change events.

    - [ ] figure out dependencies in and between pipelines, to run them in the correct order

    Possible: Yes
    Implemented: Kind of

    Components lookup data on the store and care about resolving dependencies.
    Pipelines just work with data.

### render data
    - [ ] convert tables of data into formats to render (e.g. geojson FeatureCollections for maps, chart-specific formats for charts)

    Possible: Yes
    Implemented: No
    Components can be of different types. And component type defines its output type.
    If output type is enforced, we can rely on it when using the output in Vue Component.

    - [ ] pass data to dumb renderer components

    Possible: Yes
    Implemented: Yes
    Components emit on change events.

### listen for pipeline/transform requests from renderer components
    - [ ] figure out what pipelines or pipeline steps require computation

    Possible: Yes
    Implemented: Partial
    Caching is not implemented yet.
    And this is a ripe area for smart optimizations.

    - [ ] execute pipelines

    Possible: Yes
    Implemented: Yes

    - [ ] emit/broadcast/post/send data to renderer component

    Possible: Yes
    Implemented: Yes
    Components emit on change events.

## SHOULD
    - [ ] handle sharing of outputs publicly or to specific users

    Possible: Yes
    Implemented: Partial

    Can add filters/transforms at the end of pipeline that depend on 'current_user' variable in Store.
    More integrated solution is possible, but not sure if needed.